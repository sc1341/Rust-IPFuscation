/*
IPFuscation (IPv4) example
Author: sc1341
Feb 28, 2024

*/
fn msf_to_rust_array() {} // to be implemented


fn shellcode_to_ip_array(mut bytes : Vec<u8>) -> Vec<String> {
    let mut ip_array: Vec<String> = Vec::new();
    let mut tmp_str = String::new();

    while (bytes.len() % 4) != 0{
        bytes.push(0x00);
    }

    for (index, &byte) in bytes.iter().enumerate() {
        tmp_str.push_str(&format!("{}", byte));
        if (index + 1) % 4 != 0 {
            tmp_str.push('.');
        } else {
            ip_array.push(tmp_str.clone());
            tmp_str.clear();
        }
    }

    ip_array
}

fn ip_array_to_shellcode(ip_array: Vec<String>) -> Vec<u8> {
    let mut bytes: Vec<u8> = Vec::new();

    for ip in ip_array.iter() {
        let octets = ip.split('.');
        for octet_str in octets {
            let octet = octet_str.parse::<u8>().unwrap();
            bytes.push(octet);
        }
    }

    bytes
}


fn main() {
    let bytes: Vec<u8> = vec![
        0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64, 0x8b, 0x50,
        0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26,
        0x31, 0xff, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7,
        0xe2, 0xf2, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b, 0x4a, 0x3c, 0x8b, 0x4c, 0x11, 0x78,
        0xe3, 0x48, 0x01, 0xd1, 0x51, 0x8b, 0x59, 0x20, 0x01, 0xd3, 0x8b, 0x49, 0x18, 0xe3,
        0x3a, 0x49, 0x8b, 0x34, 0x8b, 0x01, 0xd6, 0x31, 0xff, 0xac, 0xc1, 0xcf, 0x0d, 0x01,
        0xc7, 0x38, 0xe0, 0x75, 0xf6, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75, 0xe4, 0x58,
        0x8b, 0x58, 0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b, 0x58, 0x1c, 0x01, 0xd3,
        0x8b, 0x04, 0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a,
        0x51, 0xff, 0xe0, 0x5f, 0x5f, 0x5a, 0x8b, 0x12, 0xeb, 0x8d, 0x5d, 0x6a, 0x01, 0x8d,
        0x85, 0xb2, 0x00, 0x00, 0x00, 0x50, 0x68, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb,
        0xf0, 0xb5, 0xa2, 0x56, 0x68, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x3c, 0x06, 0x7c,
        0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x53,
        0xff, 0xd5, 0x6e, 0x6f, 0x74, 0x65, 0x70, 0x61, 0x64, 0x2e, 0x65, 0x78, 0x65, 0x00
    ];

    let mut bytes2: Vec<u8> = vec![0xde, 0xad, 0xbe,0xef];
    let ip_array : Vec<String> = shellcode_to_ip_array(bytes);
    for ip in &ip_array {
        println!("IP segment: {}", ip);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shellcode_to_ip_and_back() {
        // Original bytes to test
        let original_bytes: Vec<u8> = vec![
            192, 168, 1, 1,
            10, 0, 0, 1,
        ];

        let ip_array = shellcode_to_ip_array(original_bytes.clone());

        for ip in &ip_array {
            println!("IP segment: {}", ip);
        }

        let converted_bytes = ip_array_to_shellcode(ip_array);

        assert_eq!(original_bytes, converted_bytes);
    }
}
